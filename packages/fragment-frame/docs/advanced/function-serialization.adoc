= Function Serialization

Fragment Frame supports passing functions between parent and fragment, enabling powerful callback patterns.

== How It Works

Functions cannot be directly serialized with `JSON.stringify()`, so Fragment Frame uses a proxy pattern:

1. **Serialize**: Function is replaced with a UUID token
2. **Store**: Original function is stored in a registry
3. **Deserialize**: Token is converted to a proxy function
4. **Call**: Proxy sends a message to invoke the original function
5. **Cleanup**: Function is released when no longer needed

[mermaid]
----
flowchart TD
    A[Function Assignment] --> B[Generate UUID]
    B --> C[Store in Registry]
    C --> D[Create Token]
    D --> E[Serialize to JSON]
    E --> F[Send via PostMessage]
    F --> G[Receive Message]
    G --> H[Deserialize Token]
    H --> I[Create Proxy Function]
    I --> J{Function Called?}
    J -->|Yes| K[Send __FUNCTION_CALL__]
    K --> L[Lookup in Registry]
    L --> M[Execute Original Function]
    M --> N{Success?}
    N -->|Yes| O[Serialize Result]
    N -->|No| P[Serialize Error]
    O --> Q[Send __FUNCTION_RESPONSE__]
    P --> Q
    Q --> R[Receive Response]
    R --> S{Success?}
    S -->|Yes| T[Resolve Promise]
    S -->|No| U[Reject Promise]
    J -->|Cleanup| V[Send __FUNCTION_RELEASE__]
    V --> W[Remove from Registry]

    style A fill:#4A90E2,stroke:#2563EB,stroke-width:2px,color:#fff
    style M fill:#FFA726,stroke:#F57C00,stroke-width:2px,color:#000
    style T fill:#66BB6A,stroke:#388E3C,stroke-width:2px,color:#fff
    style U fill:#EF5350,stroke:#C62828,stroke-width:2px,color:#fff
    style W fill:#757575,stroke:#616161,stroke-width:2px,color:#fff
----

== Parent → Fragment

=== Passing Functions

[source,typescript]
----
const fragment = document.querySelector('fragment-frame');

// Pass callback functions
fragment.onSave = async (data) => {
  console.log('Saving:', data);
  await api.save(data);
  return { success: true };
};

fragment.onCancel = () => {
  router.back();
};

fragment.onValidate = (field, value) => {
  if (field === 'email') {
    return /^[^@]+@[^@]+$/.test(value);
  }
  return true;
};
----

=== Fragment Calls Functions

[source,typescript]
----
import { frameSDK } from '@zomme/fragment-frame/sdk';

// Fragment can call parent functions
const result = await frameSDK.props.onSave({ name: 'John', email: 'john@example.com' });
console.log(result); // { success: true }

// Synchronous calls also work
const isValid = frameSDK.props.onValidate('email', 'test@example.com');
console.log(isValid); // true

// No parameters
frameSDK.props.onCancel();
----

== Fragment → Parent

=== Registering Functions with `register()` (Recommended)

The `register()` method provides an explicit, ergonomic API for exposing fragment functions to the parent:

[source,typescript]
----
import { frameSDK } from '@zomme/fragment-frame/sdk';

// Register single function
const unregister1 = frameSDK.register('refresh', () => {
  console.log('Refreshing data');
  loadData();
});

// Register multiple functions
const unregister2 = frameSDK.register({
  export: async (format) => {
    const data = await generateExport(format);
    return data;
  },
  close: () => {
    cleanup();
  },
});

// Optional: cleanup when component unmounts
onUnmount(() => {
  unregister1();
  unregister2();
});
----

**Benefits:**

* **Clear intent**: Method name communicates purpose explicitly
* **Built-in cleanup**: Returns function to unregister
* **Type validation**: Throws error if non-function values provided
* **Standard convention**: Uses `'register'` event consistently

=== Parent Receives Registered Functions

[source,typescript]
----
const fragment = document.querySelector('fragment-frame');
const actions = {};

// Listen to standard 'register' event
fragment.addEventListener('register', async (event) => {
  const functions = event.detail;

  // Accumulate registered functions
  Object.assign(actions, functions);

  // Call functions
  if (functions.refresh) {
    functions.refresh();
  }
});

// Use accumulated functions later
await actions.export('csv');
actions.close();

// Optional: listen for unregister
fragment.addEventListener('unregister', (event) => {
  console.log('Functions unregistered:', event.detail.functions);
  // Clean up cache
  for (const name of event.detail.functions) {
    delete actions[name];
  }
});
----

=== Alternative: Using `emit()` for Custom Events

For advanced use cases or custom event names, you can still use `emit()`:

[source,typescript]
----
import { frameSDK } from '@zomme/fragment-frame/sdk';

// Fragment emits custom event with functions
frameSDK.emit('my-custom-actions', {
  refresh: () => {
    console.log('Refreshing data');
    loadData();
  },
  export: async (format) => {
    const data = await generateExport(format);
    return data;
  },
});
----

[source,typescript]
----
const fragment = document.querySelector('fragment-frame');

// Parent listens to custom event
fragment.addEventListener('my-custom-actions', async (event) => {
  const actions = event.detail;

  // Call fragment functions
  actions.refresh();

  const exportedData = await actions.export('csv');
  console.log(exportedData);
});
----

== Complex Scenarios

=== Nested Functions

Functions can contain other functions:

[source,typescript]
----
// Parent
fragment.config = {
  api: {
    get: async (url) => fetch(url).then((r) => r.json()),
    post: async (url, data) => fetch(url, { method: 'POST', body: JSON.stringify(data) }),
  },
  onError: (err) => console.error(err),
};

// Fragment
const response = await frameSDK.props.config.api.get('/api/users');
console.log(response);
----

=== Function Arrays

[source,typescript]
----
// Parent
fragment.validators = [
  (value) => value.length > 0 || 'Required',
  (value) => value.length < 100 || 'Too long',
  (value) => /^[a-zA-Z]+$/.test(value) || 'Letters only',
];

// Fragment
const errors = frameSDK.props.validators
  .map((validator) => validator(inputValue))
  .filter((result) => result !== true);

if (errors.length > 0) {
  console.log('Validation errors:', errors);
}
----

=== Function in Return Values

Functions can be returned from function calls:

[source,typescript]
----
// Parent
fragment.createLogger = (prefix) => {
  return (message) => {
    console.log(`[${prefix}] ${message}`);
  };
};

// Fragment
const logger = await frameSDK.props.createLogger('UserForm');
logger('Form submitted'); // Logs: [UserForm] Form submitted
logger('Validation passed'); // Logs: [UserForm] Validation passed
----

== Lifecycle

=== Function Registration

When a function is passed:

[source,typescript]
----
fragment.onSave = async (data) => { ... };
----

1. Function is assigned a UUID: `"abc-123"`
2. Stored in `_functionRegistry`: `Map { "abc-123" => [Function] }`
3. Added to `_trackedFunctions`: `Set { "abc-123" }`
4. Serialized to: `{ __fn: "abc-123", __meta: { name: "onSave" } }`
5. Sent in `__ATTRIBUTE_CHANGE__` message

=== Function Invocation

When the fragment calls the function:

[source,typescript]
----
await frameSDK.props.onSave({ name: 'John' });
----

1. Proxy function is called
2. Generates call ID: `"call-456"`
3. Sends `__FUNCTION_CALL__` message:
   ```json
   {
     "type": "__FUNCTION_CALL__",
     "callId": "call-456",
     "fnId": "abc-123",
     "params": [{ "name": "John" }]
   }
   ```
4. Parent receives message, looks up function in registry
5. Executes function with deserialized params
6. Sends `__FUNCTION_RESPONSE__` message:
   ```json
   {
     "type": "__FUNCTION_RESPONSE__",
     "callId": "call-456",
     "success": true,
     "result": { "success": true }
   }
   ```
7. Fragment resolves promise with result

[mermaid]
----
sequenceDiagram
    participant F as Fragment<br/>(Iframe)
    participant FP as Proxy Function
    participant PM as PostMessage
    participant PR as Parent Registry
    participant PF as Parent Function

    F->>FP: Call onSave(data)
    FP->>FP: Generate callId
    FP->>PM: Send __FUNCTION_CALL__<br/>{callId, fnId, params}
    PM->>PR: Receive message
    PR->>PR: Lookup fnId in registry
    PR->>PF: Execute function(params)

    alt Success
        PF-->>PR: Return result
        PR->>PM: Send __FUNCTION_RESPONSE__<br/>{callId, success: true, result}
        PM-->>FP: Receive response
        FP-->>F: Resolve promise with result
    else Error
        PF-->>PR: Throw error
        PR->>PM: Send __FUNCTION_RESPONSE__<br/>{callId, success: false, error}
        PM-->>FP: Receive response
        FP-->>F: Reject promise with error
    end

    Note over F,PF: Round-trip time: ~2-5ms
----

=== Function Cleanup

Functions are released when:

1. **Parent disconnects**: Element removed from DOM
   ```typescript
   disconnectedCallback() {
     for (const fnId of this._trackedFunctions) {
       this.sendToIframe({ type: '__FUNCTION_RELEASE__', fnId });
     }
   }
   ```

2. **Fragment unloads**: Window closes or navigates away
   ```typescript
   window.addEventListener('beforeunload', () => {
     for (const fnId of frameSDK.trackedFunctions) {
       frameSDK.sendToParent({ type: '__FUNCTION_RELEASE__', fnId });
     }
   });
   ```

3. **Function is replaced**:
   ```typescript
   fragment.onSave = newFunction; // Old function is released
   ```

== Error Handling

Errors are propagated across boundaries:

[source,typescript]
----
// Parent
fragment.riskyOperation = () => {
  throw new Error('Something went wrong');
};

// Fragment
try {
  await frameSDK.props.riskyOperation();
} catch (error) {
  console.error('Caught error:', error.message); // "Something went wrong"
}
----

Behind the scenes:

1. Parent function throws error
2. Error is caught and sent in response:
   ```json
   {
     "type": "__FUNCTION_RESPONSE__",
     "callId": "call-456",
     "success": false,
     "error": "Something went wrong"
   }
   ```
3. Fragment promise is rejected with error

[mermaid]
----
flowchart TD
    A[Fragment calls proxy] --> B[Send __FUNCTION_CALL__]
    B --> C[Parent receives message]
    C --> D[Lookup function in registry]
    D --> E{Function exists?}
    E -->|No| F[Create error:<br/>Function not found]
    E -->|Yes| G[Execute function]
    G --> H{Function throws?}
    H -->|Yes| I[Catch error]
    H -->|No| J[Get return value]
    I --> K[Serialize error:<br/>{success: false, error: message}]
    J --> L[Serialize result:<br/>{success: true, result: value}]
    K --> M[Send __FUNCTION_RESPONSE__]
    F --> M
    L --> M
    M --> N[Fragment receives response]
    N --> O{Success?}
    O -->|Yes| P[Resolve promise with result]
    O -->|No| Q[Create Error object]
    Q --> R[Reject promise with error]
    R --> S[Fragment catch block receives error]

    style H fill:#EF5350,stroke:#C62828,stroke-width:2px,color:#fff
    style I fill:#EF5350,stroke:#C62828,stroke-width:2px,color:#fff
    style K fill:#EF5350,stroke:#C62828,stroke-width:2px,color:#fff
    style Q fill:#EF5350,stroke:#C62828,stroke-width:2px,color:#fff
    style R fill:#EF5350,stroke:#C62828,stroke-width:2px,color:#fff
    style P fill:#66BB6A,stroke:#388E3C,stroke-width:2px,color:#fff
    style J fill:#66BB6A,stroke:#388E3C,stroke-width:2px,color:#fff
    style L fill:#66BB6A,stroke:#388E3C,stroke-width:2px,color:#fff
----

== Timeout

Function calls timeout after 5 seconds:

[source,typescript]
----
// Parent
fragment.slowOperation = async () => {
  await new Promise((resolve) => setTimeout(resolve, 15000)); // 15 seconds
  return 'done';
};

// Fragment
try {
  await frameSDK.props.slowOperation();
} catch (error) {
  console.error(error.message); // "Function call timeout: abc-123"
}
----

**Best practice:** For long operations, return a Promise immediately and resolve it when done:

[source,typescript]
----
fragment.longOperation = () => {
  // Return promise immediately
  return new Promise((resolve) => {
    // Do work asynchronously
    setTimeout(() => {
      resolve('done');
    }, 30000);
  });
};
----

== Performance Considerations

* **Serialization overhead**: Each function call requires 2 messages (call + response)
* **Latency**: PostMessage has ~1ms overhead per message
* **Batch calls**: For multiple calls, consider batching:

[source,typescript]
----
// Instead of individual calls
await frameSDK.props.validate('name', 'John');
await frameSDK.props.validate('email', 'john@example.com');

// Batch validate
const result = await frameSDK.props.validateAll({
  name: 'John',
  email: 'john@example.com',
});
----

== Security

Functions are validated:

* **Origin check**: Messages must come from correct origin
* **Source check**: Messages must come from actual iframe/parent
* **Function ID check**: Only registered functions can be called
* **No eval**: Functions are called directly, never evaluated from strings

== Limitations

* **Function serialization**: Only function calls work, not function inspection
* **Context binding**: `this` binding may not work as expected
* **Closures**: Closed-over variables are not accessible across boundaries
* **Timeout**: 5-second limit on function execution

== Best Practices

1. **Use descriptive names**: `onSave`, `onValidate`, `onCancel`
2. **Return promises**: For async operations
3. **Handle errors**: Always catch and handle errors
4. **Document function signatures**: Use TypeScript types
5. **Batch operations**: Reduce message overhead
6. **Cleanup**: Functions are auto-cleaned, but can manually release if needed
