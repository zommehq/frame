= Vue Integration

Fragment Frame provides official Vue 3 support with dedicated packages for both parent and child applications.

== Parent Application (Vue 3)

=== Installation

[source,bash]
----
bun add @zomme/fragment-frame-vue
----

=== Using the FragmentFrame Component

The `@zomme/fragment-frame-vue` package provides a ready-to-use Vue component wrapper:

[source,vue]
----
<script setup lang="ts">
import { FragmentFrame } from '@zomme/fragment-frame-vue';

function handleReady(event: CustomEvent) {
  console.log('Fragment ready:', event.detail);
}

function handleNavigate(event: CustomEvent) {
  console.log('Navigation:', event.detail);
}
</script>

<template>
  <FragmentFrame
    name="user-app"
    src="http://localhost:3001"
    base="/users"
    theme="dark"
    :api-url="apiUrl"
    @ready="handleReady"
    @navigate="handleNavigate"
  />
</template>
----

The `FragmentFrame` component:

* Automatically handles property updates and passes them to the custom element
* Provides TypeScript-safe event handling
* Manages lifecycle and cleanup
* Supports all standard HTML attributes and custom properties

=== Using the Web Component Directly

You can also use the native web component directly:

[source,vue]
----
<script setup lang="ts">
import '@zomme/fragment-frame';
</script>

<template>
  <fragment-frame
    name="user-app"
    src="http://localhost:3001"
    base="/users"
    theme="dark"
  />
</template>
----

=== Type-Safe Wrapper (Custom)

For advanced use cases, you can create your own wrapper:

[source,vue]
----
<script setup lang="ts">
import { ref, watchEffect } from 'vue';
import type { FragmentFrame } from '@zomme/fragment-frame';

interface Props {
  apiUrl: string;
  name: string;
  src: string;
  theme: 'light' | 'dark';
}

const props = defineProps<Props>();
const fragmentRef = ref<FragmentFrame>();

watchEffect(() => {
  if (!fragmentRef.value) return;
  fragmentRef.value.apiUrl = props.apiUrl;
  fragmentRef.value.theme = props.theme;
});
</script>

<template>
  <fragment-frame ref="fragmentRef" :name="props.name" :src="props.src" />
</template>
----

== Fragment Application (Vue 3)

=== Installation

[source,bash]
----
bun add @zomme/fragment-frame-vue
----

=== Using the useFrameSDK Composable

The `useFrameSDK` composable provides a reactive way to interact with the parent frame:

[source,typescript]
----
import { createApp } from 'vue';
import App from './App.vue';

createApp(App).mount('#app');
----

[source,vue]
----
<script setup lang="ts">
import { useFrameSDK } from '@zomme/fragment-frame-vue';

interface Props {
  apiUrl: string;
  name: string;
  theme: 'light' | 'dark';
}

const { emit, isReady, on, onAttr, props, sdkAvailable } = useFrameSDK<Props>();

// Listen to events from parent
on('refresh', () => {
  console.log('Parent requested refresh');
});

// Listen to specific attribute changes
onAttr('theme', (newTheme) => {
  console.log('Theme changed:', newTheme);
});

// Emit events to parent
function notifyParent() {
  emit('user-action', { action: 'save', timestamp: Date.now() });
}
</script>

<template>
  <div v-if="isReady" :data-theme="props.theme">
    <h1>Fragment: {{ props.name }}</h1>
    <p>API URL: {{ props.apiUrl }}</p>
    <p>SDK Available: {{ sdkAvailable }}</p>
    <button @click="notifyParent">Notify Parent</button>
  </div>
  <div v-else>
    Loading fragment...
  </div>
</template>
----

=== useFrameSDK API Reference

The `useFrameSDK` composable returns an object with the following properties and methods:

==== props

[cols="1,3"]
|===
| Type | `T` (generic type parameter)
| Description | Reactive object containing all props passed from the parent frame. Automatically updated when attributes change.
|===

[source,typescript]
----
interface Props {
  theme: 'light' | 'dark';
  user: { name: string };
}

const { props } = useFrameSDK<Props>();
// props.theme and props.user are reactive
----

==== isReady

[cols="1,3"]
|===
| Type | `Ref<boolean>`
| Description | Reactive boolean indicating if the SDK has finished initialization. Use this to conditionally render content.
|===

[source,vue]
----
<template>
  <div v-if="isReady">
    Content ready to display
  </div>
</template>
----

==== sdkAvailable

[cols="1,3"]
|===
| Type | `Ref<boolean>`
| Description | Reactive boolean indicating if the frame SDK is available. Returns `false` when running in standalone mode (outside of a parent frame).
|===

[source,typescript]
----
const { sdkAvailable } = useFrameSDK();

if (!sdkAvailable.value) {
  console.log('Running in standalone mode');
}
----

==== emit(event: string, data?: unknown)

[cols="1,3"]
|===
| Parameters | `event`: Event name, `data`: Optional event payload
| Returns | `void`
| Description | Sends a custom event to the parent frame. When running in standalone mode, logs the event to console instead.
|===

[source,typescript]
----
const { emit } = useFrameSDK();

emit('save-completed', { id: 123 });
emit('navigation-requested', { path: '/users' });
----

==== on(event: string, handler: (data: unknown) => void)

[cols="1,3"]
|===
| Parameters | `event`: Event name, `handler`: Callback function
| Returns | `() => void` (cleanup function)
| Description | Listens to custom events from the parent frame. Returns a function to remove the listener.
|===

[source,typescript]
----
const { on } = useFrameSDK();

const unsubscribe = on('refresh', (data) => {
  console.log('Refresh requested:', data);
});

// Clean up when needed
onUnmounted(() => {
  unsubscribe();
});
----

==== onAttr(attrName: string, handler: (value: unknown) => void)

[cols="1,3"]
|===
| Parameters | `attrName`: Attribute name, `handler`: Callback function
| Returns | `() => void` (cleanup function)
| Description | Listens to changes in a specific attribute from the parent frame. Automatically updates the `props` object and calls the handler.
|===

[source,typescript]
----
const { onAttr } = useFrameSDK();

onAttr('theme', (newTheme) => {
  console.log('Theme changed to:', newTheme);
  // props.theme is already updated
});
----

=== Using the SDK Directly

For projects not using the Vue package, you can use the SDK directly:

[source,typescript]
----
import { createApp } from 'vue';
import App from './App.vue';
import { frameSDK } from '@zomme/fragment-frame/sdk';

frameSDK.initialize().then(() => {
  createApp(App).mount('#app');
});
----

[source,vue]
----
<script setup lang="ts">
import { ref, onUnmounted } from 'vue';
import { frameSDK } from '@zomme/fragment-frame/sdk';

const config = ref(frameSDK.props);

const unwatch = frameSDK.watch(['theme'], (changes) => {
  if ('theme' in changes && changes.theme) {
    const [newTheme] = changes.theme;
    config.value.theme = newTheme;
  }
});

onUnmounted(() => {
  unwatch();
});
</script>

<template>
  <div :data-theme="config.theme">
    <h1>Fragment: {{ config.name }}</h1>
  </div>
</template>
----

=== Complete Example

Parent application:

[source,vue]
----
<script setup lang="ts">
import { ref } from 'vue';
import { FragmentFrame } from '@zomme/fragment-frame-vue';

const theme = ref<'light' | 'dark'>('light');
const userCount = ref(0);

function handleUserAction(event: CustomEvent) {
  console.log('User action:', event.detail);
  userCount.value++;
}
</script>

<template>
  <div>
    <button @click="theme = theme === 'light' ? 'dark' : 'light'">
      Toggle Theme
    </button>

    <FragmentFrame
      name="user-app"
      src="http://localhost:3001"
      :theme="theme"
      :api-url="'https://api.example.com'"
      @user-action="handleUserAction"
    />

    <p>User actions: {{ userCount }}</p>
  </div>
</template>
----

Fragment application:

[source,vue]
----
<script setup lang="ts">
import { useFrameSDK } from '@zomme/fragment-frame-vue';

interface Props {
  apiUrl: string;
  name: string;
  theme: 'light' | 'dark';
}

const { emit, isReady, props, sdkAvailable } = useFrameSDK<Props>();

function saveUser() {
  emit('user-action', { action: 'save', timestamp: Date.now() });
}
</script>

<template>
  <div v-if="isReady" :data-theme="props.theme">
    <h1>{{ props.name }}</h1>
    <p>API: {{ props.apiUrl }}</p>
    <p>Mode: {{ sdkAvailable ? 'Embedded' : 'Standalone' }}</p>
    <button @click="saveUser">Save User</button>
  </div>
</template>
----
