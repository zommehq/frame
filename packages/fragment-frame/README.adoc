= Fragment Frame
:toc: left
:toclevels: 3
:sectnums:
:sectnumlevels: 5
:icons: font
:source-highlighter: highlightjs

ifdef::env-github[]
:tip-caption: ğŸ’¡
:note-caption: â„¹ï¸
:important-caption: âš ï¸
:caution-caption: ğŸ”¥
:warning-caption: âš ï¸
endif::[]

toc::[]

== Overview

Fragment Frame provides Web Components and SDK for building micro-frontend architectures using iframe isolation with type-safe communication.

=== Key Features

* **Web Components** - Custom `<fragment-frame>` element for embedding micro-frontends
* **Framework Agnostic** - Works with React, Vue, Angular, or vanilla JS
* **Type-Safe Communication** - MessageChannel-based protocol with TypeScript types
* **High Performance** - Dedicated MessageChannel for fast, isolated communication
* **Dynamic Attributes** - Pass data via attributes or properties (supports objects)
* **Bidirectional API** - Parent can call fragment methods, fragments can emit events
* **Secure Isolation** - Configurable iframe sandbox with origin validation
* **Hot Reload Support** - Attribute changes propagate to running fragments

== Installation

[source,bash]
----
bun add @zomme/fragment-frame
----

== Quick Start

=== Parent Application (Shell)

[source,typescript]
----
// Import and register the Web Component
import '@zomme/fragment-frame';

// Use in HTML
<fragment-frame
  name="my-app"
  src="http://localhost:3000"
  base="/my-app"
  api-url="https://api.example.com"
  theme="dark"
></fragment-frame>
----

=== Fragment Application

[source,typescript]
----
import { frameSDK } from '@zomme/fragment-frame/sdk';

// Initialize SDK
await frameSDK.initialize();

// Access configuration
const config = frameSDK.props;
console.log(config.base);    // "/my-app"
console.log(config.apiUrl);  // "https://api.example.com"
console.log(config.theme);   // "dark"

// Emit custom events
frameSDK.emit('user-action', { type: 'click', id: 123 });

// Listen to attribute changes
// Watch for property changes
const unwatch = frameSDK.watch(['apiUrl'], (changes) => {
  if ('apiUrl' in changes && changes.apiUrl) {
    const [newUrl, oldUrl] = changes.apiUrl;
    console.log(`API URL changed from ${oldUrl} to ${newUrl}`);
  }
});

// Later: cleanup
unwatch();

// Call parent functions (passed via props)
const result = await frameSDK.props.onSave({ name: 'John' });
console.log(result); // { success: true }
----

== Core Concepts

include::docs/concepts/architecture.adoc[leveloffset=+2]

include::docs/concepts/communication.adoc[leveloffset=+2]

include::docs/concepts/attributes.adoc[leveloffset=+2]

include::docs/concepts/lifecycle.adoc[leveloffset=+2]

== API Reference

include::docs/references/fragment-frame.adoc[leveloffset=+2]

include::docs/references/sdk.adoc[leveloffset=+2]

include::docs/references/types.adoc[leveloffset=+2]

== Framework Integration

include::docs/frameworks/react.adoc[leveloffset=+2]

include::docs/frameworks/vue.adoc[leveloffset=+2]

include::docs/frameworks/angular.adoc[leveloffset=+2]

== Advanced Usage

include::docs/advanced/function-serialization.adoc[leveloffset=+2]

include::docs/advanced/event-system.adoc[leveloffset=+2]

include::docs/advanced/security.adoc[leveloffset=+2]

== Tech Stack

TypeScript, Web Components API, MessageChannel API

== Project Structure

[source]
----
packages/fragment-frame/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ constants.ts              # Message type constants
â”‚   â”œâ”€â”€ fragment-frame.ts         # Web Component implementation
â”‚   â”œâ”€â”€ sdk.ts                    # SDK for fragments
â”‚   â”œâ”€â”€ types.ts                  # TypeScript types
â”‚   â””â”€â”€ helpers/                  # Helper utilities
â”‚       â”œâ”€â”€ function-manager.ts   # Function serialization manager
â”‚       â”œâ”€â”€ logger.ts             # Logging utilities
â”‚       â”œâ”€â”€ message-validators.ts # Message validation
â”‚       â”œâ”€â”€ serialization.ts      # Data serialization
â”‚       â”œâ”€â”€ string-utils.ts       # String utilities
â”‚       â””â”€â”€ type-guards.ts        # Type guard functions
â”œâ”€â”€ tests/                        # Test files
â”œâ”€â”€ docs/                         # Documentation
â”œâ”€â”€ package.json
â””â”€â”€ README.adoc                   # This file
----

== Message Flow

[source]
----
Parent Application <--> <fragment-frame> <--> iframe <--> Fragment App
                          Web Component    MessageChannel    SDK
                                           (dedicated port)
----

=== Initialization Flow

[source]
----
1. Parent creates <fragment-frame> element
2. Element creates iframe and MessageChannel
3. Element loads fragment in iframe
4. Element sends __INIT__ message via window.postMessage with:
   - Configuration and props
   - MessagePort (transferred to fragment)
5. Fragment SDK receives __INIT__:
   - Validates parent origin (one-time check)
   - Extracts MessagePort from event.ports[0]
   - Sets up message handler on port
6. Fragment sends __READY__ message via MessagePort
7. Element marks fragment as ready
8. Bidirectional communication enabled via dedicated MessageChannel
----

=== Attribute Change Flow

[source]
----
// Via setAttribute (MutationObserver)
element.setAttribute('theme', 'dark')
  -> MutationObserver detects change
  -> Sends __ATTRIBUTE_CHANGE__ message
  -> Fragment SDK receives and emits event

// Via property (Proxy)
element.theme = 'dark'
  -> Proxy intercepts assignment
  -> Sends __ATTRIBUTE_CHANGE__ message
  -> Fragment SDK receives and emits event
----

== Design Principles

. **Secure by default** - iframe sandbox, origin validation, CORS-safe
. **Framework agnostic** - Works with any frontend framework
. **Type-safe** - Full TypeScript support with strict types
. **Developer friendly** - Simple API, clear error messages
. **Hot reload ready** - Dynamic attribute updates without page reload
. **Minimal overhead** - Lightweight Web Component, no heavy dependencies

== Browser Support

* Chrome/Edge 89+
* Firefox 88+
* Safari 15+

Requires support for:
* Web Components (Custom Elements v1)
* Proxy
* MutationObserver
* MessageChannel API

== License

MIT
