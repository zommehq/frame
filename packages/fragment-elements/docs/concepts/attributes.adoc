= Attributes and Properties

Fragment Elements supports both HTML attributes and JavaScript properties for passing data to fragments.

== Attribute Types

=== Fixed Attributes

These control the fragment instance and are read only once:

[cols="1,2,1"]
|===
| Attribute | Purpose | Required

| `name`
| Fragment identifier, used as default base path
| Yes

| `src`
| Fragment URL (must include protocol)
| Yes

| `base`
| Base path for fragment router
| No (defaults to `/${name}`)

| `sandbox`
| iframe sandbox permissions
| No (has secure defaults)
|===

**Important:** Fixed attributes are **not reactive**. Changing them after initialization has no effect.

[source,html]
----
<fragment-frame
  name="my-app"
  src="http://localhost:3000"
  base="/custom-path"
  sandbox="allow-scripts allow-same-origin"
></fragment-frame>
----

=== Dynamic Attributes

Any other attribute is passed to the fragment and is **reactive**:

[source,html]
----
<fragment-frame
  name="my-app"
  src="http://localhost:3000"
  api-url="https://api.example.com"
  theme="dark"
  user-id="123"
></fragment-frame>
----

Fragment receives (kebab-case converted to camelCase):

[source,typescript]
----
{
  name: "my-app",
  base: "/my-app",
  apiUrl: "https://api.example.com",
  theme: "dark",
  userId: "123"
}
----

== Properties vs Attributes

=== Attributes (HTML)

* Limited to **strings** only
* Set via `setAttribute()` or HTML markup
* Use kebab-case naming: `api-url`, `user-id`

[source,html]
----
<fragment-frame api-url="https://api.example.com"></fragment-frame>
----

[source,typescript]
----
fragment.setAttribute('theme', 'dark');
----

=== Properties (JavaScript)

* Support **any type**: objects, arrays, functions, etc.
* Set via direct property assignment
* Use camelCase naming: `apiUrl`, `userId`

[source,typescript]
----
const fragment = document.querySelector('fragment-frame');

// Complex objects
fragment.userData = { name: 'John', role: 'admin' };

// Arrays
fragment.permissions = ['read', 'write'];

// Functions
fragment.onUserClick = (data) => {
  console.log('User clicked:', data);
};
----

**Recommendation:** Use properties for complex data, attributes for simple configuration.

== Attribute Name Conversion

Attribute names are automatically converted:

[cols="1,1,1"]
|===
| HTML Attribute | Property Name | Fragment Receives

| `api-url`
| `apiUrl`
| `apiUrl`

| `user-id`
| `userId`
| `userId`

| `data-theme`
| `dataTheme`
| `dataTheme`

| `theme`
| `theme`
| `theme`
|===

**Rules:**

1. Hyphens are removed
2. Character after hyphen is uppercased
3. Result is camelCase

== Change Detection

Fragment Elements uses **two mechanisms** to detect changes:

=== MutationObserver (Attributes)

Detects changes via `setAttribute()`:

[source,typescript]
----
// Detected by MutationObserver
fragment.setAttribute('theme', 'dark');
----

[source]
----
setAttribute() → MutationObserver → ATTRIBUTE_CHANGE message → Fragment
----

=== Proxy (Properties)

Detects changes via property assignment:

[source,typescript]
----
// Detected by Proxy
fragment.theme = 'dark';
fragment.userData = { name: 'John' };
----

[source]
----
Property set → Proxy trap → ATTRIBUTE_CHANGE message → Fragment
----

TIP: Both mechanisms work transparently. Use whichever is more convenient.

== Reactive Updates

When an attribute/property changes, the fragment is notified:

[source,typescript]
----
// Parent changes theme
fragment.theme = 'dark';

// Fragment receives update
frameSDK.on('attr:theme', (newTheme) => {
  console.log('Theme changed to:', newTheme); // "dark"
  applyTheme(newTheme);
});
----

**Update flow:**

1. Parent changes attribute/property
2. Change detected (MutationObserver or Proxy)
3. `__ATTRIBUTE_CHANGE__` message sent to fragment
4. Fragment SDK updates `frameSDK.props`
5. Fragment SDK emits `attr:${name}` event
6. Application code reacts to change

== Initial vs Dynamic Values

=== Initial Values

Set before fragment is ready:

[source,typescript]
----
const fragment = document.createElement('fragment-frame');
fragment.setAttribute('name', 'my-app');
fragment.setAttribute('src', 'http://localhost:3000');
fragment.theme = 'dark';          // Queued
fragment.apiUrl = 'https://api.com'; // Queued

document.body.appendChild(fragment);
----

These values are collected and sent in the `__INIT__` message.

=== Dynamic Updates

Set after fragment is ready:

[source,typescript]
----
fragment.addEventListener('ready', () => {
  // Fragment is ready, updates sent immediately
  fragment.theme = 'light';
  fragment.permissions = ['read', 'write', 'delete'];
});
----

Each change sends an `__ATTRIBUTE_CHANGE__` message.

== Best Practices

=== Use Attributes for Configuration

Simple, string-based configuration:

[source,html]
----
<fragment-frame
  name="my-app"
  src="http://localhost:3000"
  environment="production"
  api-version="v2"
></fragment-frame>
----

=== Use Properties for Complex Data

Objects, arrays, functions:

[source,typescript]
----
fragment.config = {
  api: { baseUrl: 'https://api.com', timeout: 5000 },
  features: ['feature-a', 'feature-b'],
  theme: { mode: 'dark', primary: '#007bff' }
};

fragment.onDataChange = (data) => {
  console.log('Data updated:', data);
};
----

=== Avoid Frequent Updates

Debounce rapid changes:

[source,typescript]
----
// BAD: Sends 1000 messages
for (let i = 0; i < 1000; i++) {
  fragment.counter = i;
}

// GOOD: Batch updates
let counter = 0;
const interval = setInterval(() => {
  fragment.counter = counter++;
  if (counter >= 1000) clearInterval(interval);
}, 100);
----

=== Listen to Specific Attributes

Use `attr:` prefix for targeted listening:

[source,typescript]
----
// Listen to theme changes only
frameSDK.on('attr:theme', (theme) => {
  applyTheme(theme);
});

// Listen to API URL changes only
frameSDK.on('attr:apiUrl', (url) => {
  updateApiClient(url);
});
----

== Function Properties

Functions can be passed as properties for callbacks:

[source,typescript]
----
// Parent provides callbacks
fragment.onSave = async (data) => {
  await api.save(data);
  return { success: true };
};

fragment.onCancel = () => {
  router.back();
};

// Fragment calls them
const result = await frameSDK.props.onSave({ name: 'John' });
console.log(result); // { success: true }

frameSDK.props.onCancel();
----

**Naming convention:** Use `on*` prefix for event handlers:

* `onSave`, `onCancel`, `onLoad`
* `onUserClick`, `onDataChange`
* `onError`, `onSuccess`

TIP: Functions have a 5-second timeout. For long operations, return a Promise and resolve it when done.
