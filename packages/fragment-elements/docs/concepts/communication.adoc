= Communication Protocol

Fragment Elements uses MessageChannel API for dedicated, secure communication between parent and fragment applications.

== MessageChannel vs Window PostMessage

Fragment Elements uses **MessageChannel** instead of `window.postMessage` directly for several advantages:

**Performance:**

* Dedicated communication channel (no origin filtering overhead on every message)
* Direct port-to-port messaging (faster than window-based routing)
* Reduced message processing overhead

**Security:**

* Origin validation only on initial handshake (INIT message)
* Isolated communication channel per fragment
* No risk of message interception by other scripts

**Cleaner Architecture:**

* No origin checking on every message after initialization
* Automatic message routing to correct recipient
* Clear ownership and lifecycle management

**How it works:**

[source,typescript]
----
// Parent creates MessageChannel
const channel = new MessageChannel();
this._port = channel.port1;

// Transfer port2 to fragment in INIT message
iframe.postMessage(
  { type: '__INIT__', payload: props },
  origin,
  [channel.port2]  // Transfer ownership
);

// Both sides use their ports directly
port.postMessage(message);
port.onmessage = (event) => handleMessage(event.data);
----

== Message Structure

All messages follow a base structure:

[source,typescript]
----
interface BaseMessage {
  type: MessageType;
  // ... type-specific fields
}
----

== Message Flow

=== Parent → Fragment

[cols="1,2,2"]
|===
| Message | Purpose | When

| `__INIT__`
| Initialize fragment with configuration and props
| After iframe loads, before fragment is ready

| `__ATTRIBUTE_CHANGE__`
| Notify attribute or property change
| When parent updates fragment attributes/properties

| `__EVENT__`
| Send event to fragment
| When parent emits event to fragment (via `emit()`)

| `__FUNCTION_CALL__`
| Call function provided by fragment
| When parent invokes a function received from fragment

| `__FUNCTION_RESPONSE__`
| Return result of function call
| Response to fragment's function call

| `__FUNCTION_RELEASE__`
| Notify function cleanup
| When parent disconnects or function is no longer needed
|===

=== Fragment → Parent

[cols="1,2,2"]
|===
| Message | Purpose | When

| `__READY__`
| Signal fragment is initialized
| After SDK receives `__INIT__` and completes setup

| `__CUSTOM_EVENT__`
| Emit custom event to parent
| When fragment calls `frameSDK.emit()`

| `__FUNCTION_CALL__`
| Call function provided by parent
| When fragment invokes a function received from parent

| `__FUNCTION_RESPONSE__`
| Return result of function call
| Response to parent's function call

| `__FUNCTION_RELEASE__`
| Notify function cleanup
| When fragment unloads or function is no longer needed
|===

== Origin Validation

Origin validation happens **only during the initial handshake** (INIT message via `window.postMessage`). After the MessageChannel is established, all subsequent communication uses the dedicated port.

=== Initial Handshake (INIT)

[source,typescript]
----
// Parent sends INIT via window.postMessage (one-time)
iframe.contentWindow.postMessage(
  { type: '__INIT__', payload: props },
  expectedOrigin,
  [channel.port2]
);

// Fragment validates origin on INIT
window.addEventListener('message', (event) => {
  if (event.data.type === '__INIT__') {
    // Validate origin ONCE
    this._parentOrigin = event.origin;

    // Extract MessagePort
    this._port = event.ports[0];

    // All future communication via port (no origin checking needed)
    this._port.onmessage = (event) => {
      this.handleMessage(event.data);
    };
  }
}, { once: true });
----

=== Why This Is Secure

**Origin validation on INIT:**

* Fragment validates parent origin when receiving MessagePort
* Only accepts MessagePort from expected origin
* Stores origin for reference (though not checked again)

**MessageChannel isolation:**

* Port is transferred directly (not accessible to other scripts)
* Only the two endpoints can communicate via the channel
* No risk of message interception after channel is established
* Malicious scripts cannot inject messages into an established channel

**Security guarantees:**

* Initial origin validation ensures correct parent
* Transferred MessagePort creates isolated communication channel
* No need for origin checking on every message (performance win)
* Prevents malicious scripts from injecting fake messages

== Serialization

=== Supported Types

Fragment Elements automatically serializes/deserializes:

* Primitives: `string`, `number`, `boolean`, `null`, `undefined`
* Objects and arrays (including nested structures)
* **Functions** (bidirectional)
* **Transferable objects**: `ArrayBuffer`, `MessagePort`, `ImageBitmap`, etc.

=== Function Serialization

Functions are automatically serialized and can be passed in both directions:

[source,typescript]
----
// Parent passes function to fragment
fragment.onUserClick = (data) => {
  console.log('User clicked:', data);
};

// Fragment receives and can call it
frameSDK.props.onUserClick({ id: 123 });
----

Behind the scenes:

1. Function is replaced with a `SerializedFunction` token:
   ```typescript
   { __fn: "uuid-123", __meta: { name: "onUserClick" } }
   ```

2. Original function is stored in registry with the UUID

3. When called, a `__FUNCTION_CALL__` message is sent

4. Result is returned via `__FUNCTION_RESPONSE__`

5. Function is released on cleanup via `__FUNCTION_RELEASE__`

TIP: Functions have a 5-second timeout. Long-running operations should use promises.

=== Transferable Objects

Transferable objects are moved (not copied) for performance:

[source,typescript]
----
// Create ArrayBuffer
const buffer = new ArrayBuffer(1024 * 1024); // 1MB

// Pass to fragment (transferred, not cloned)
fragment.imageData = buffer;

// buffer is now unusable in parent (transferred ownership)
----

**Supported transferables:**

* `ArrayBuffer`
* `MessagePort`
* `ImageBitmap`
* `OffscreenCanvas`
* `ReadableStream`
* `WritableStream`
* `TransformStream`

=== Circular Reference Handling

Circular references are detected and warned:

[source,typescript]
----
const obj = { name: 'test' };
obj.self = obj; // Circular reference

fragment.data = obj;
// Console: [fragment-frame] Circular reference detected
----

== Message Ordering

PostMessage guarantees:

* **Order preservation**: Messages arrive in the order sent
* **Atomicity**: Each message is delivered completely or not at all
* **No message loss**: Messages are queued if receiver is busy

== Error Handling

Function call errors are propagated across boundaries:

[source,typescript]
----
// Fragment throws error
frameSDK.props.onSave = () => {
  throw new Error('Save failed');
};

// Parent receives error
try {
  await fragment.onSave();
} catch (error) {
  console.error('Fragment error:', error.message); // "Save failed"
}
----

== Performance Considerations

* **Serialization cost**: Functions and complex objects have overhead
* **Message queue**: Too many rapid messages can cause lag
* **Payload size**: Keep messages under 1MB for best performance
* **Use transferables**: For large binary data (images, buffers)

TIP: For high-frequency updates (like mouse position), debounce or throttle messages.
