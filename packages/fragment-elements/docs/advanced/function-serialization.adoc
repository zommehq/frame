= Function Serialization

Fragment Elements supports passing functions between parent and fragment, enabling powerful callback patterns.

== How It Works

Functions cannot be directly serialized with `JSON.stringify()`, so Fragment Elements uses a proxy pattern:

1. **Serialize**: Function is replaced with a UUID token
2. **Store**: Original function is stored in a registry
3. **Deserialize**: Token is converted to a proxy function
4. **Call**: Proxy sends a message to invoke the original function
5. **Cleanup**: Function is released when no longer needed

== Parent → Fragment

=== Passing Functions

[source,typescript]
----
const fragment = document.querySelector('fragment-frame');

// Pass callback functions
fragment.onSave = async (data) => {
  console.log('Saving:', data);
  await api.save(data);
  return { success: true };
};

fragment.onCancel = () => {
  router.back();
};

fragment.onValidate = (field, value) => {
  if (field === 'email') {
    return /^[^@]+@[^@]+$/.test(value);
  }
  return true;
};
----

=== Fragment Calls Functions

[source,typescript]
----
import { frameSDK } from '@micro-fe/fragment-elements/sdk';

// Fragment can call parent functions
const result = await frameSDK.props.onSave({ name: 'John', email: 'john@example.com' });
console.log(result); // { success: true }

// Synchronous calls also work
const isValid = frameSDK.props.onValidate('email', 'test@example.com');
console.log(isValid); // true

// No parameters
frameSDK.props.onCancel();
----

== Fragment → Parent

=== Passing Functions from Fragment

[source,typescript]
----
import { frameSDK } from '@micro-fe/fragment-elements/sdk';

// Fragment can pass functions to parent via events
frameSDK.emit('register-actions', {
  refresh: () => {
    console.log('Refreshing data');
    loadData();
  },
  export: async (format) => {
    const data = await generateExport(format);
    return data;
  },
});
----

=== Parent Calls Fragment Functions

[source,typescript]
----
const fragment = document.querySelector('fragment-frame');

fragment.addEventListener('register-actions', async (event) => {
  const actions = event.detail;

  // Call fragment functions
  actions.refresh();

  const exportedData = await actions.export('csv');
  console.log(exportedData);
});
----

== Complex Scenarios

=== Nested Functions

Functions can contain other functions:

[source,typescript]
----
// Parent
fragment.config = {
  api: {
    get: async (url) => fetch(url).then((r) => r.json()),
    post: async (url, data) => fetch(url, { method: 'POST', body: JSON.stringify(data) }),
  },
  onError: (err) => console.error(err),
};

// Fragment
const response = await frameSDK.props.config.api.get('/api/users');
console.log(response);
----

=== Function Arrays

[source,typescript]
----
// Parent
fragment.validators = [
  (value) => value.length > 0 || 'Required',
  (value) => value.length < 100 || 'Too long',
  (value) => /^[a-zA-Z]+$/.test(value) || 'Letters only',
];

// Fragment
const errors = frameSDK.props.validators
  .map((validator) => validator(inputValue))
  .filter((result) => result !== true);

if (errors.length > 0) {
  console.log('Validation errors:', errors);
}
----

=== Function in Return Values

Functions can be returned from function calls:

[source,typescript]
----
// Parent
fragment.createLogger = (prefix) => {
  return (message) => {
    console.log(`[${prefix}] ${message}`);
  };
};

// Fragment
const logger = await frameSDK.props.createLogger('UserForm');
logger('Form submitted'); // Logs: [UserForm] Form submitted
logger('Validation passed'); // Logs: [UserForm] Validation passed
----

== Lifecycle

=== Function Registration

When a function is passed:

[source,typescript]
----
fragment.onSave = async (data) => { ... };
----

1. Function is assigned a UUID: `"abc-123"`
2. Stored in `_functionRegistry`: `Map { "abc-123" => [Function] }`
3. Added to `_trackedFunctions`: `Set { "abc-123" }`
4. Serialized to: `{ __fn: "abc-123", __meta: { name: "onSave" } }`
5. Sent in `__ATTRIBUTE_CHANGE__` message

=== Function Invocation

When the fragment calls the function:

[source,typescript]
----
await frameSDK.props.onSave({ name: 'John' });
----

1. Proxy function is called
2. Generates call ID: `"call-456"`
3. Sends `__FUNCTION_CALL__` message:
   ```json
   {
     "type": "__FUNCTION_CALL__",
     "callId": "call-456",
     "fnId": "abc-123",
     "params": [{ "name": "John" }]
   }
   ```
4. Parent receives message, looks up function in registry
5. Executes function with deserialized params
6. Sends `__FUNCTION_RESPONSE__` message:
   ```json
   {
     "type": "__FUNCTION_RESPONSE__",
     "callId": "call-456",
     "success": true,
     "result": { "success": true }
   }
   ```
7. Fragment resolves promise with result

=== Function Cleanup

Functions are released when:

1. **Parent disconnects**: Element removed from DOM
   ```typescript
   disconnectedCallback() {
     for (const fnId of this._trackedFunctions) {
       this.sendToIframe({ type: '__FUNCTION_RELEASE__', fnId });
     }
   }
   ```

2. **Fragment unloads**: Window closes or navigates away
   ```typescript
   window.addEventListener('beforeunload', () => {
     for (const fnId of frameSDK.trackedFunctions) {
       frameSDK.sendToParent({ type: '__FUNCTION_RELEASE__', fnId });
     }
   });
   ```

3. **Function is replaced**:
   ```typescript
   fragment.onSave = newFunction; // Old function is released
   ```

== Error Handling

Errors are propagated across boundaries:

[source,typescript]
----
// Parent
fragment.riskyOperation = () => {
  throw new Error('Something went wrong');
};

// Fragment
try {
  await frameSDK.props.riskyOperation();
} catch (error) {
  console.error('Caught error:', error.message); // "Something went wrong"
}
----

Behind the scenes:

1. Parent function throws error
2. Error is caught and sent in response:
   ```json
   {
     "type": "__FUNCTION_RESPONSE__",
     "callId": "call-456",
     "success": false,
     "error": "Something went wrong"
   }
   ```
3. Fragment promise is rejected with error

== Timeout

Function calls timeout after 5 seconds:

[source,typescript]
----
// Parent
fragment.slowOperation = async () => {
  await new Promise((resolve) => setTimeout(resolve, 15000)); // 15 seconds
  return 'done';
};

// Fragment
try {
  await frameSDK.props.slowOperation();
} catch (error) {
  console.error(error.message); // "Function call timeout: abc-123"
}
----

**Best practice:** For long operations, return a Promise immediately and resolve it when done:

[source,typescript]
----
fragment.longOperation = () => {
  // Return promise immediately
  return new Promise((resolve) => {
    // Do work asynchronously
    setTimeout(() => {
      resolve('done');
    }, 30000);
  });
};
----

== Performance Considerations

* **Serialization overhead**: Each function call requires 2 messages (call + response)
* **Latency**: PostMessage has ~1ms overhead per message
* **Batch calls**: For multiple calls, consider batching:

[source,typescript]
----
// Instead of individual calls
await frameSDK.props.validate('name', 'John');
await frameSDK.props.validate('email', 'john@example.com');

// Batch validate
const result = await frameSDK.props.validateAll({
  name: 'John',
  email: 'john@example.com',
});
----

== Security

Functions are validated:

* **Origin check**: Messages must come from correct origin
* **Source check**: Messages must come from actual iframe/parent
* **Function ID check**: Only registered functions can be called
* **No eval**: Functions are called directly, never evaluated from strings

== Limitations

* **Function serialization**: Only function calls work, not function inspection
* **Context binding**: `this` binding may not work as expected
* **Closures**: Closed-over variables are not accessible across boundaries
* **Timeout**: 5-second limit on function execution

== Best Practices

1. **Use descriptive names**: `onSave`, `onValidate`, `onCancel`
2. **Return promises**: For async operations
3. **Handle errors**: Always catch and handle errors
4. **Document function signatures**: Use TypeScript types
5. **Batch operations**: Reduce message overhead
6. **Cleanup**: Functions are auto-cleaned, but can manually release if needed
