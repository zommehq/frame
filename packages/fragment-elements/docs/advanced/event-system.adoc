= Event System

Fragment Elements provides a bidirectional event system for communication between parent and fragment.

== Fragment → Parent Events

=== Emitting Events

[source,typescript]
----
import { frameSDK } from '@micro-fe/fragment-elements/sdk';

// Emit event without data
frameSDK.emit('ready');

// Emit event with data
frameSDK.emit('user-selected', { userId: 123 });

// Emit event with complex data
frameSDK.emit('form-submitted', {
  values: { name: 'John', email: 'john@example.com' },
  timestamp: Date.now(),
});
----

=== Listening in Parent

Events are dispatched as DOM CustomEvents:

[source,typescript]
----
const fragment = document.querySelector('fragment-frame');

// Listen to specific event
fragment.addEventListener('user-selected', (event) => {
  console.log('User selected:', event.detail.userId);
});

// Listen to form-submitted
fragment.addEventListener('form-submitted', (event) => {
  console.log('Form values:', event.detail.values);
  console.log('Timestamp:', event.detail.timestamp);
});
----

=== Property Handlers

You can also use property handlers:

[source,typescript]
----
const fragment = document.querySelector('fragment-frame');

// Property handler (on + eventName)
fragment.onuserselected = (detail) => {
  console.log('User selected:', detail.userId);
};

fragment.onformsubmitted = (detail) => {
  console.log('Form values:', detail.values);
};
----

NOTE: Property handlers normalize event names by removing `-`, `:`, `.` characters.

== Parent → Fragment Events

=== Sending Events from Parent

While not built-in, you can use parent-provided functions:

[source,typescript]
----
// Parent provides event emitter via props
fragment.parentEvents = {
  emit: (eventName, data) => {
    // Handle event in parent
    console.log(`Parent event: ${eventName}`, data);
  },
};

// Fragment listens and emits back
frameSDK.on('parent-event', (data) => {
  console.log('Received from parent:', data);
});
----

Better approach - use attribute changes:

[source,typescript]
----
// Parent changes attribute
fragment.currentUser = { id: 123, name: 'John' };

// Fragment listens to attribute change
frameSDK.on('attr:currentUser', (user) => {
  console.log('User changed:', user);
  updateUI(user);
});
----

== Built-in Events

=== `ready` Event

Emitted when fragment is initialized:

[source,typescript]
----
fragment.addEventListener('ready', () => {
  console.log('Fragment is ready');
  // Safe to interact with fragment now
});
----

== Event Naming

=== Naming Conventions

Use descriptive, kebab-case names:

* ✅ `user-selected`, `form-submitted`, `data-loaded`
* ❌ `userSelected`, `formSubmitted`, `dataLoaded` (camelCase - harder to read in HTML)
* ❌ `click`, `submit` (too generic)

=== Namespace Events

For complex applications, use namespaces:

[source,typescript]
----
// User-related events
frameSDK.emit('user:login', { userId: 123 });
frameSDK.emit('user:logout');
frameSDK.emit('user:profile-updated', { name: 'John' });

// Form-related events
frameSDK.emit('form:submit', { values: {...} });
frameSDK.emit('form:reset');
frameSDK.emit('form:validation-error', { field: 'email', error: 'Invalid' });

// Data-related events
frameSDK.emit('data:loaded', { items: [...] });
frameSDK.emit('data:error', { message: 'Failed to load' });
----

Parent can listen with event name filtering:

[source,typescript]
----
fragment.addEventListener('user:login', (e) => { ... });
fragment.addEventListener('user:logout', (e) => { ... });
----

== Event Data

=== Simple Data

[source,typescript]
----
frameSDK.emit('counter-updated', 42);
frameSDK.emit('status-changed', 'active');
frameSDK.emit('toggle-changed', true);
----

=== Complex Objects

[source,typescript]
----
frameSDK.emit('user-updated', {
  id: 123,
  name: 'John Doe',
  email: 'john@example.com',
  roles: ['admin', 'editor'],
  metadata: {
    lastLogin: new Date().toISOString(),
    loginCount: 42,
  },
});
----

=== Functions in Events

Events can include functions:

[source,typescript]
----
frameSDK.emit('action-registered', {
  name: 'refresh',
  execute: () => {
    console.log('Refreshing...');
    loadData();
  },
});

// Parent receives and can call the function
fragment.addEventListener('action-registered', (event) => {
  const { name, execute } = event.detail;
  console.log(`Registered action: ${name}`);

  // Call fragment function
  execute();
});
----

=== Transferable Objects

Events support transferable objects:

[source,typescript]
----
const buffer = new ArrayBuffer(1024);
frameSDK.emit('data-ready', { buffer });

// buffer is now transferred to parent (unusable in fragment)
----

== Event Patterns

=== Request-Response Pattern

Fragment requests data from parent:

[source,typescript]
----
// Fragment emits request
frameSDK.emit('fetch-user-data', { userId: 123 });

// Listen for response
frameSDK.on('attr:userData', (data) => {
  console.log('Received user data:', data);
});

// Parent handles request
fragment.addEventListener('fetch-user-data', async (event) => {
  const { userId } = event.detail;
  const userData = await api.getUser(userId);

  // Send response via attribute
  fragment.userData = userData;
});
----

=== Notification Pattern

Fragment notifies parent of state changes:

[source,typescript]
----
// Fragment notifies
frameSDK.emit('loading', true);

// ... do work

frameSDK.emit('loading', false);
frameSDK.emit('data-loaded', { items });

// Parent updates UI
fragment.addEventListener('loading', (event) => {
  const isLoading = event.detail;
  showSpinner(isLoading);
});

fragment.addEventListener('data-loaded', (event) => {
  console.log('Loaded items:', event.detail.items);
});
----

=== Command Pattern

Parent sends commands to fragment:

[source,typescript]
----
// Parent sends command via function
fragment.executeCommand = async (command) => {
  switch (command.type) {
    case 'refresh':
      await loadData();
      break;
    case 'save':
      await saveData(command.data);
      break;
    case 'reset':
      resetForm();
      break;
  }
};

// Fragment executes
await frameSDK.props.executeCommand({ type: 'refresh' });
await frameSDK.props.executeCommand({ type: 'save', data: {...} });
----

== Error Events

=== Emitting Errors

[source,typescript]
----
try {
  await riskyOperation();
} catch (error) {
  frameSDK.emit('error', {
    message: error.message,
    stack: error.stack,
    context: 'user-form',
  });
}
----

=== Handling Errors in Parent

[source,typescript]
----
fragment.addEventListener('error', (event) => {
  const { message, stack, context } = event.detail;

  console.error(`Error in ${context}:`, message);

  // Log to error tracking service
  errorTracker.log({
    message,
    stack,
    fragment: fragment.getAttribute('name'),
  });

  // Show user-friendly message
  showToast('Something went wrong. Please try again.');
});
----

== Best Practices

=== Use Events for Notifications

Events are best for fire-and-forget notifications:

[source,typescript]
----
// ✅ Good: One-way notification
frameSDK.emit('user-clicked-button', { buttonId: 'save' });

// ❌ Bad: Should use function for request-response
frameSDK.emit('get-user-data', { userId: 123 });
// How do you get the response?
----

=== Use Functions for Request-Response

[source,typescript]
----
// ✅ Good: Function returns response
const userData = await frameSDK.props.getUserData(123);

// ❌ Bad: Event doesn't return anything
frameSDK.emit('get-user-data', { userId: 123 });
----

=== Document Your Events

[source,typescript]
----
/**
 * Events emitted by UserForm fragment:
 *
 * - user:selected - When user is selected
 *   detail: { userId: number, userName: string }
 *
 * - form:submitted - When form is submitted
 *   detail: { values: Record<string, unknown> }
 *
 * - form:cancelled - When form is cancelled
 *   detail: undefined
 *
 * - error - When an error occurs
 *   detail: { message: string, context: string }
 */
----

=== Namespace Your Events

Avoid name collisions:

[source,typescript]
----
// ✅ Good: Namespaced
frameSDK.emit('userform:submit', data);
frameSDK.emit('userform:cancel');

// ❌ Bad: Generic names might conflict
frameSDK.emit('submit', data);
frameSDK.emit('cancel');
----

=== Keep Event Data Serializable

Avoid circular references and complex objects:

[source,typescript]
----
// ✅ Good: Simple, serializable
frameSDK.emit('data-loaded', {
  items: [...],
  count: 42,
  timestamp: Date.now(),
});

// ❌ Bad: DOM nodes, circular refs
const form = document.querySelector('form');
frameSDK.emit('form-ready', { form }); // Won't serialize
----

=== Cleanup Event Listeners

Always remove event listeners:

[source,typescript]
----
const handleUserSelected = (event) => {
  console.log(event.detail);
};

fragment.addEventListener('user-selected', handleUserSelected);

// Later...
fragment.removeEventListener('user-selected', handleUserSelected);
----
