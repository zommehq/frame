= Fragment Elements
:toc: left
:toclevels: 3
:sectnums:
:sectnumlevels: 5
:icons: font
:source-highlighter: highlightjs

ifdef::env-github[]
:tip-caption: üí°
:note-caption: ‚ÑπÔ∏è
:important-caption: ‚ö†Ô∏è
:caution-caption: üî•
:warning-caption: ‚ö†Ô∏è
endif::[]

toc::[]

== Overview

Fragment Elements provides Web Components and SDK for building micro-frontend architectures using iframe isolation with type-safe communication.

=== Key Features

* **Web Components** - Custom `<fragment-frame>` element for embedding micro-frontends
* **Framework Agnostic** - Works with React, Vue, Angular, Solid, or vanilla JS
* **Type-Safe Communication** - MessageChannel-based protocol with TypeScript types
* **High Performance** - Dedicated MessageChannel for fast, isolated communication
* **Dynamic Attributes** - Pass data via attributes or properties (supports objects)
* **Bidirectional API** - Parent can call fragment methods, fragments can emit events
* **Secure Isolation** - Configurable iframe sandbox with origin validation
* **Hot Reload Support** - Attribute changes propagate to running fragments

== Installation

[source,bash]
----
bun add @micro-fe/fragment-elements
----

== Quick Start

=== Parent Application (Shell)

[source,typescript]
----
// Import and register the Web Component
import '@micro-fe/fragment-elements/fragment-frame';

// Use in HTML
<fragment-frame
  name="my-app"
  src="http://localhost:3000"
  base="/my-app"
  api-url="https://api.example.com"
  theme="dark"
></fragment-frame>
----

=== Fragment Application

[source,typescript]
----
import { frameSDK } from '@micro-fe/fragment-elements/sdk';

// Initialize SDK
await frameSDK.initialize();

// Access configuration
const config = frameSDK.props;
console.log(config.base);    // "/my-app"
console.log(config.apiUrl);  // "https://api.example.com"
console.log(config.theme);   // "dark"

// Emit custom events
frameSDK.emit('user-action', { type: 'click', id: 123 });

// Listen to attribute changes
frameSDK.on('attr:apiUrl', (newUrl) => {
  console.log('API URL changed:', newUrl);
});

// Call parent functions (passed via props)
const result = await frameSDK.props.onSave({ name: 'John' });
console.log(result); // { success: true }
----

== Core Concepts

include::docs/concepts/architecture.adoc[leveloffset=+2]

include::docs/concepts/communication.adoc[leveloffset=+2]

include::docs/concepts/attributes.adoc[leveloffset=+2]

include::docs/concepts/lifecycle.adoc[leveloffset=+2]

== API Reference

include::docs/references/fragment-frame.adoc[leveloffset=+2]

include::docs/references/sdk.adoc[leveloffset=+2]

include::docs/references/types.adoc[leveloffset=+2]

== Framework Integration

include::docs/frameworks/react.adoc[leveloffset=+2]

include::docs/frameworks/vue.adoc[leveloffset=+2]

include::docs/frameworks/angular.adoc[leveloffset=+2]

include::docs/frameworks/solid.adoc[leveloffset=+2]

== Advanced Usage

include::docs/advanced/function-serialization.adoc[leveloffset=+2]

include::docs/advanced/event-system.adoc[leveloffset=+2]

include::docs/advanced/security.adoc[leveloffset=+2]

== Tech Stack

TypeScript, Web Components API, MessageChannel API

== Project Structure

[source]
----
packages/fragment-elements/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ constants.ts       # Message type constants
‚îÇ   ‚îú‚îÄ‚îÄ fragment-frame.ts  # Web Component implementation
‚îÇ   ‚îú‚îÄ‚îÄ sdk.ts             # SDK for fragments
‚îÇ   ‚îú‚îÄ‚îÄ types.ts           # TypeScript types
‚îÇ   ‚îî‚îÄ‚îÄ index.ts           # Package exports
‚îú‚îÄ‚îÄ docs/                  # Documentation
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ README.adoc           # This file
----

== Message Flow

[source]
----
Parent Application <--> <fragment-frame> <--> iframe <--> Fragment App
                          Web Component    MessageChannel    SDK
                                           (dedicated port)
----

=== Initialization Flow

[source]
----
1. Parent creates <fragment-frame> element
2. Element creates iframe and MessageChannel
3. Element loads fragment in iframe
4. Element sends __INIT__ message via window.postMessage with:
   - Configuration and props
   - MessagePort (transferred to fragment)
5. Fragment SDK receives __INIT__:
   - Validates parent origin (one-time check)
   - Extracts MessagePort from event.ports[0]
   - Sets up message handler on port
6. Fragment sends __READY__ message via MessagePort
7. Element marks fragment as ready
8. Bidirectional communication enabled via dedicated MessageChannel
----

=== Attribute Change Flow

[source]
----
// Via setAttribute (MutationObserver)
element.setAttribute('theme', 'dark')
  -> MutationObserver detects change
  -> Sends ATTRIBUTE_CHANGE message
  -> Fragment SDK receives and emits event

// Via property (Proxy)
element.theme = 'dark'
  -> Proxy intercepts assignment
  -> Sends ATTRIBUTE_CHANGE message
  -> Fragment SDK receives and emits event
----

== Design Principles

. **Secure by default** - iframe sandbox, origin validation, CORS-safe
. **Framework agnostic** - Works with any frontend framework
. **Type-safe** - Full TypeScript support with strict types
. **Developer friendly** - Simple API, clear error messages
. **Hot reload ready** - Dynamic attribute updates without page reload
. **Minimal overhead** - Lightweight Web Component, no heavy dependencies

== Browser Support

* Chrome/Edge 89+
* Firefox 88+
* Safari 15+

Requires support for:
* Web Components (Custom Elements v1)
* Proxy
* MutationObserver
* MessageChannel API

== License

MIT
