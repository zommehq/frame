= Function Serialization

Frame supports passing functions between parent and frame, enabling powerful callback patterns.

== Important: Functions Are NOT Actually Serialized

Despite the name "function serialization", **functions themselves are never serialized**. This is technically impossible in JavaScript because you cannot serialize:

* Function code and implementation
* Closures and captured variables
* Execution context and `this` binding

Instead, Frame implements a **Remote Procedure Call (RPC)** system over `postMessage`:

[cols="1,1", options="header"]
|===
| What IS Serialized | What is NOT Serialized

| Function call arguments
| Function code

| Function return values
| Function closures

| Function reference IDs (UUIDs)
| Execution context

| Error messages
| Variable scope
|===

== How It Really Works: RPC via postMessage

Frame creates a **registry-based proxy system**:

1. **Register**: Function is stored in a registry with a UUID reference
2. **Send Reference**: Only the UUID is sent across the iframe boundary
3. **Create Proxy**: Receiver creates a proxy function that references the UUID
4. **RPC Call**: When proxy is called, it sends a postMessage with:
   - Function UUID (which function to call)
   - Arguments (these ARE serialized via `structuredClone`)
5. **Execute**: Sender looks up the real function and executes it
6. **Return Result**: Result is serialized and sent back via postMessage
7. **Cleanup**: UUID references are released when no longer needed

**Analogy**: It's like calling a restaurant for delivery. You don't get the recipe (function code), you get a menu item number (UUID). When you "call" that number with your preferences (arguments), the restaurant executes the real recipe and delivers the result.

== Visual Example: What Gets Sent

[source,typescript]
----
// PARENT SIDE
const realFunction = async (data) => {
  console.log('Executing in parent:', data);
  return { success: true };
};

// Step 1: Register function → get UUID
functionRegistry.set('abc-123', realFunction);

// Step 2: Send ONLY the reference ID
postMessage({
  type: 'PROPS_UPDATED',
  props: {
    saveCallback: { __fn: 'abc-123' }  // ← Only ID, NOT the function code!
  }
});
----

[source,typescript]
----
// FRAME SIDE
// Step 3: Receive ID and create proxy
const proxy = (...args) => {
  // When called, notify parent to execute 'abc-123'
  return new Promise((resolve) => {
    postMessage({
      type: 'FUNCTION_CALL',
      fnId: 'abc-123',
      args: args  // ← Arguments ARE serialized
    });

    // Wait for response...
    waitForResponse(resolve);
  });
};

// Step 4: Use proxy as normal function
await proxy({ name: 'John' });  // args are serialized and sent
----

[source,typescript]
----
// PARENT SIDE
// Step 5: Receive FUNCTION_CALL
const fn = functionRegistry.get('abc-123');  // Get real function
const result = await fn({ name: 'John' });    // Execute

// Step 6: Send result back
postMessage({
  type: 'FUNCTION_RESULT',
  fnId: 'abc-123',
  result: { success: true }  // ← Result IS serialized
});
----

[mermaid]
----
flowchart TD
    A[Function Assignment] --> B[Generate UUID]
    B --> C[Store in Registry]
    C --> D[Create Reference Token]
    D --> E[Send Token via PostMessage]
    E --> F[Receive Token]
    F --> G[Create Proxy Function]
    G --> H{Proxy Called?}
    H -->|Yes| I[Serialize Arguments]
    I --> J[Send RPC: FUNCTION_CALL<br/>fnId + args]
    J --> K[Lookup UUID in Registry]
    K --> L[Get Real Function]
    L --> M[Execute with Args]
    M --> N{Success?}
    N -->|Yes| O[Serialize Result]
    N -->|No| P[Serialize Error]
    O --> Q[Send RPC: FUNCTION_RESULT<br/>result]
    P --> Q
    Q --> R[Receive Result]
    R --> S{Success?}
    S -->|Yes| T[Resolve Promise]
    S -->|No| U[Reject Promise]
    H -->|Cleanup| V[Send FUNCTION_RELEASE]
    V --> W[Remove from Registry]

    style A fill:#4A90E2,stroke:#2563EB,stroke-width:2px,color:#fff
    style C fill:#FFA726,stroke:#F57C00,stroke-width:2px,color:#000
    style M fill:#FFA726,stroke:#F57C00,stroke-width:2px,color:#000
    style T fill:#66BB6A,stroke:#388E3C,stroke-width:2px,color:#fff
    style U fill:#EF5350,stroke:#C62828,stroke-width:2px,color:#fff
    style W fill:#757575,stroke:#616161,stroke-width:2px,color:#fff

    note1[Real function NEVER leaves<br/>its original context]
    note2[Only UUID references<br/>cross the boundary]
    note3[Arguments & results<br/>are serialized]

    style note1 fill:#FFF9C4,stroke:#F57F17,stroke-width:2px
    style note2 fill:#FFF9C4,stroke:#F57F17,stroke-width:2px
    style note3 fill:#FFF9C4,stroke:#F57F17,stroke-width:2px
----

== Parent → Frame

=== Passing Functions

[source,typescript]
----
const frame = document.querySelector('z-frame');

// Pass callback functions
frame.onSave = async (data) => {
  console.log('Saving:', data);
  await api.save(data);
  return { success: true };
};

frame.onCancel = () => {
  router.back();
};

frame.onValidate = (field, value) => {
  if (field === 'email') {
    return /^[^@]+@[^@]+$/.test(value);
  }
  return true;
};
----

=== Frame Calls Functions

[source,typescript]
----
import { frameSDK } from '@zomme/frame/sdk';

// Frame can call parent functions
const result = await frameSDK.props.onSave({ name: 'John', email: 'john@example.com' });
console.log(result); // { success: true }

// Synchronous calls also work
const isValid = frameSDK.props.onValidate('email', 'test@example.com');
console.log(isValid); // true

// No parameters
frameSDK.props.onCancel();
----

== Frame → Parent

=== Registering Functions with `register()` (Recommended)

The `register()` method provides an explicit, ergonomic API for exposing frame functions to the parent:

[source,typescript]
----
import { frameSDK } from '@zomme/frame/sdk';

// Register single function
const unregister1 = frameSDK.register('refresh', () => {
  console.log('Refreshing data');
  loadData();
});

// Register multiple functions
const unregister2 = frameSDK.register({
  export: async (format) => {
    const data = await generateExport(format);
    return data;
  },
  close: () => {
    cleanup();
  },
});

// Optional: cleanup when component unmounts
onUnmount(() => {
  unregister1();
  unregister2();
});
----

**Benefits:**

* **Clear intent**: Method name communicates purpose explicitly
* **Built-in cleanup**: Returns function to unregister
* **Type validation**: Throws error if non-function values provided
* **Standard convention**: Uses `'register'` event consistently

=== Parent Receives Registered Functions

[source,typescript]
----
const frame = document.querySelector('z-frame');
const actions = {};

// Listen to standard 'register' event
frame.addEventListener('register', async (event) => {
  const functions = event.detail;

  // Accumulate registered functions
  Object.assign(actions, functions);

  // Call functions
  if (functions.refresh) {
    functions.refresh();
  }
});

// Use accumulated functions later
await actions.export('csv');
actions.close();

// Optional: listen for unregister
frame.addEventListener('unregister', (event) => {
  console.log('Functions unregistered:', event.detail.functions);
  // Clean up cache
  for (const name of event.detail.functions) {
    delete actions[name];
  }
});
----

=== Alternative: Using `emit()` for Custom Events

For advanced use cases or custom event names, you can still use `emit()`:

[source,typescript]
----
import { frameSDK } from '@zomme/frame/sdk';

// Frame emits custom event with functions
frameSDK.emit('my-custom-actions', {
  refresh: () => {
    console.log('Refreshing data');
    loadData();
  },
  export: async (format) => {
    const data = await generateExport(format);
    return data;
  },
});
----

[source,typescript]
----
const frame = document.querySelector('z-frame');

// Parent listens to custom event
frame.addEventListener('my-custom-actions', async (event) => {
  const actions = event.detail;

  // Call frame functions
  actions.refresh();

  const exportedData = await actions.export('csv');
  console.log(exportedData);
});
----

== Complex Scenarios

=== Nested Functions

Functions can contain other functions:

[source,typescript]
----
// Parent
frame.config = {
  api: {
    get: async (url) => fetch(url).then((r) => r.json()),
    post: async (url, data) => fetch(url, { method: 'POST', body: JSON.stringify(data) }),
  },
  onError: (err) => console.error(err),
};

// Frame
const response = await frameSDK.props.config.api.get('/api/users');
console.log(response);
----

=== Function Arrays

[source,typescript]
----
// Parent
frame.validators = [
  (value) => value.length > 0 || 'Required',
  (value) => value.length < 100 || 'Too long',
  (value) => /^[a-zA-Z]+$/.test(value) || 'Letters only',
];

// Frame
const errors = frameSDK.props.validators
  .map((validator) => validator(inputValue))
  .filter((result) => result !== true);

if (errors.length > 0) {
  console.log('Validation errors:', errors);
}
----

=== Function in Return Values

Functions can be returned from function calls:

[source,typescript]
----
// Parent
frame.createLogger = (prefix) => {
  return (message) => {
    console.log(`[${prefix}] ${message}`);
  };
};

// Frame
const logger = await frameSDK.props.createLogger('UserForm');
logger('Form submitted'); // Logs: [UserForm] Form submitted
logger('Validation passed'); // Logs: [UserForm] Validation passed
----

== Lifecycle

=== Function Registration (Initial Setup)

When a function is passed:

[source,typescript]
----
frame.onSave = async (data) => { ... };
----

**What happens:**

1. **Function is stored locally**: `_functionRegistry.set("abc-123", realFunction)`
   - The function **stays in parent memory**
   - Only accessible from parent context

2. **UUID reference is created**: Token `{ __fn: "abc-123" }`
   - This is what gets sent across the boundary
   - Not the function code itself!

3. **Reference is sent via postMessage**:
   ```json
   {
     "type": "__ATTRIBUTE_CHANGE__",
     "props": {
       "onSave": { "__fn": "abc-123" }
     }
   }
   ```

4. **Frame creates proxy**:
   ```typescript
   // Frame receives token and creates callable proxy
   frameSDK.props.onSave = (...args) => {
     return sendRPCCall("abc-123", args);
   };
   ```

=== RPC Function Call (Remote Execution)

When the frame calls the proxy:

[source,typescript]
----
await frameSDK.props.onSave({ name: 'John' });
----

**Complete RPC flow:**

1. **Frame: Serialize arguments**
   ```typescript
   const serializedArgs = structuredClone([{ name: 'John' }]);
   ```

2. **Frame: Send RPC request via postMessage**
   ```json
   {
     "type": "__FUNCTION_CALL__",
     "callId": "call-456",
     "fnId": "abc-123",
     "params": [{ "name": "John" }]
   }
   ```

3. **Parent: Receive RPC request**
   - Look up function in registry: `const fn = registry.get("abc-123")`
   - Function found: `async (data) => { ... }`

4. **Parent: Execute real function**
   ```typescript
   const result = await fn({ name: 'John' });
   // result = { success: true }
   ```

5. **Parent: Serialize result and send RPC response**
   ```json
   {
     "type": "__FUNCTION_RESPONSE__",
     "callId": "call-456",
     "success": true,
     "result": { "success": true }
   }
   ```

6. **Frame: Deserialize result**
   ```typescript
   const result = structuredClone(response.result);
   ```

7. **Frame: Resolve proxy promise**
   ```typescript
   proxyPromise.resolve({ success: true });
   ```

**Summary**: The function **never leaves the parent**. Only **messages with IDs and arguments** travel across the iframe boundary.

[mermaid]
----
sequenceDiagram
    participant F as Frame<br/>(Iframe)
    participant FP as Proxy Function
    participant PM as PostMessage
    participant PR as Parent Registry
    participant PF as Parent Function

    F->>FP: Call onSave(data)
    FP->>FP: Generate callId
    FP->>PM: Send __FUNCTION_CALL__<br/>{callId, fnId, params}
    PM->>PR: Receive message
    PR->>PR: Lookup fnId in registry
    PR->>PF: Execute function(params)

    alt Success
        PF-->>PR: Return result
        PR->>PM: Send __FUNCTION_RESPONSE__<br/>{callId, success: true, result}
        PM-->>FP: Receive response
        FP-->>F: Resolve promise with result
    else Error
        PF-->>PR: Throw error
        PR->>PM: Send __FUNCTION_RESPONSE__<br/>{callId, success: false, error}
        PM-->>FP: Receive response
        FP-->>F: Reject promise with error
    end

    Note over F,PF: Round-trip time: ~2-5ms
----

=== Function Cleanup

Functions are released when:

1. **Parent disconnects**: Element removed from DOM
   ```typescript
   disconnectedCallback() {
     for (const fnId of this._trackedFunctions) {
       this.sendToIframe({ type: '__FUNCTION_RELEASE__', fnId });
     }
   }
   ```

2. **Frame unloads**: Window closes or navigates away
   ```typescript
   window.addEventListener('beforeunload', () => {
     for (const fnId of frameSDK.trackedFunctions) {
       frameSDK.sendToParent({ type: '__FUNCTION_RELEASE__', fnId });
     }
   });
   ```

3. **Function is replaced**:
   ```typescript
   frame.onSave = newFunction; // Old function is released
   ```

== Error Handling

Errors are propagated across boundaries:

[source,typescript]
----
// Parent
frame.riskyOperation = () => {
  throw new Error('Something went wrong');
};

// Frame
try {
  await frameSDK.props.riskyOperation();
} catch (error) {
  console.error('Caught error:', error.message); // "Something went wrong"
}
----

Behind the scenes:

1. Parent function throws error
2. Error is caught and sent in response:
   ```json
   {
     "type": "__FUNCTION_RESPONSE__",
     "callId": "call-456",
     "success": false,
     "error": "Something went wrong"
   }
   ```
3. Frame promise is rejected with error

[mermaid]
----
flowchart TD
    A[Frame calls proxy] --> B[Send __FUNCTION_CALL__]
    B --> C[Parent receives message]
    C --> D[Lookup function in registry]
    D --> E{Function exists?}
    E -->|No| F[Create error:<br/>Function not found]
    E -->|Yes| G[Execute function]
    G --> H{Function throws?}
    H -->|Yes| I[Catch error]
    H -->|No| J[Get return value]
    I --> K[Serialize error:<br/>{success: false, error: message}]
    J --> L[Serialize result:<br/>{success: true, result: value}]
    K --> M[Send __FUNCTION_RESPONSE__]
    F --> M
    L --> M
    M --> N[Frame receives response]
    N --> O{Success?}
    O -->|Yes| P[Resolve promise with result]
    O -->|No| Q[Create Error object]
    Q --> R[Reject promise with error]
    R --> S[Frame catch block receives error]

    style H fill:#EF5350,stroke:#C62828,stroke-width:2px,color:#fff
    style I fill:#EF5350,stroke:#C62828,stroke-width:2px,color:#fff
    style K fill:#EF5350,stroke:#C62828,stroke-width:2px,color:#fff
    style Q fill:#EF5350,stroke:#C62828,stroke-width:2px,color:#fff
    style R fill:#EF5350,stroke:#C62828,stroke-width:2px,color:#fff
    style P fill:#66BB6A,stroke:#388E3C,stroke-width:2px,color:#fff
    style J fill:#66BB6A,stroke:#388E3C,stroke-width:2px,color:#fff
    style L fill:#66BB6A,stroke:#388E3C,stroke-width:2px,color:#fff
----

== Timeout

Function calls timeout after 5 seconds:

[source,typescript]
----
// Parent
frame.slowOperation = async () => {
  await new Promise((resolve) => setTimeout(resolve, 15000)); // 15 seconds
  return 'done';
};

// Frame
try {
  await frameSDK.props.slowOperation();
} catch (error) {
  console.error(error.message); // "Function call timeout: abc-123"
}
----

**Best practice:** For long operations, return a Promise immediately and resolve it when done:

[source,typescript]
----
frame.longOperation = () => {
  // Return promise immediately
  return new Promise((resolve) => {
    // Do work asynchronously
    setTimeout(() => {
      resolve('done');
    }, 30000);
  });
};
----

== Performance Considerations

* **Serialization overhead**: Each function call requires 2 messages (call + response)
* **Latency**: PostMessage has ~1ms overhead per message
* **Batch calls**: For multiple calls, consider batching:

[source,typescript]
----
// Instead of individual calls
await frameSDK.props.validate('name', 'John');
await frameSDK.props.validate('email', 'john@example.com');

// Batch validate
const result = await frameSDK.props.validateAll({
  name: 'John',
  email: 'john@example.com',
});
----

== Security

Functions are validated:

* **Origin check**: Messages must come from correct origin
* **Source check**: Messages must come from actual iframe/parent
* **Function ID check**: Only registered functions can be called
* **No eval**: Functions are called directly, never evaluated from strings

== What Actually Gets Serialized

To be crystal clear about what crosses the iframe boundary:

=== ✅ DOES Get Serialized (Crosses Boundary)

[cols="1,2", options="header"]
|===
| Item | Example

| Function reference IDs (UUIDs)
| `{ __fn: "abc-123" }`

| Function call arguments
| `{ name: "John", age: 30 }`

| Function return values
| `{ success: true, data: [...] }`

| Error messages
| `"Validation failed: email required"`

| Primitive types
| `string`, `number`, `boolean`, `null`

| Plain objects
| `{ key: "value" }`

| Arrays
| `[1, 2, 3]`, `["a", "b"]`

| Transferable objects
| `ArrayBuffer`, `ImageBitmap`
|===

=== ❌ Does NOT Get Serialized (Stays Local)

[cols="1,2", options="header"]
|===
| Item | Why Not

| Function implementation code
| Cannot serialize code/logic

| Closures and captured variables
| Scoping doesn't transfer

| `this` binding context
| Context is environment-specific

| Prototypes and class instances
| Only plain objects work

| DOM nodes
| Cannot be cloned across origins

| Functions in nested objects
| These become UUID references

| Symbols
| Not serializable

| `undefined` values
| Converted to `null` in transfer
|===

=== What This Means in Practice

[source,typescript]
----
// PARENT
let counter = 0;  // Local variable

frame.increment = () => {
  counter++;  // ✅ Works: accesses parent's closure
  return counter;
};

// FRAME
const result1 = await frameSDK.props.increment();  // 1
const result2 = await frameSDK.props.increment();  // 2

// ✅ Function has access to its original closure (counter)
// ❌ Frame does NOT have access to counter directly
// ✅ Only the return values (1, 2) cross the boundary
----

[source,typescript]
----
// PARENT
class UserService {
  constructor(apiKey) {
    this.apiKey = apiKey;
  }

  async save(data) {
    // ✅ 'this' works: function executes in parent context
    return fetch('/api/save', {
      headers: { 'Authorization': this.apiKey },
      body: JSON.stringify(data)
    });
  }
}

const service = new UserService('secret-key');

// Pass instance method
frame.onSave = service.save.bind(service);

// FRAME
await frameSDK.props.onSave({ name: 'John' });
// ✅ Works: 'this.apiKey' is accessed in parent context
// ✅ Arguments { name: 'John' } are serialized and sent
// ✅ Return value is serialized and sent back
// ❌ Frame never sees 'apiKey' or UserService class
----

== Limitations

Understanding what gets serialized helps explain the limitations:

* **Function inspection**: Cannot read function source code or properties from the other side
* **Context binding**: `this` works only because function executes in its original context
* **Closures**: Work perfectly because function never leaves its environment
* **Timeout**: 5-second limit on RPC calls (not function execution itself)
* **Argument types**: Only serializable types work (no DOM nodes, class instances, etc.)

== Why Call It "Serialization" Then?

The term "function serialization" is used because:

1. **From the developer's perspective**, it *feels* like functions are being serialized
   - You pass a function on one side
   - You call it on the other side
   - It "just works"

2. **The API hides the RPC complexity**
   - No need to manually send messages
   - No need to manage callbacks
   - No need to handle promise resolution

3. **Industry convention**
   - Common term in remote communication frameworks
   - Easier to search and learn about
   - Conveys "making functions work across boundaries"

But technically, it's more accurate to say:

* **Function references are serialized** (as UUIDs)
* **Function calls are executed remotely** (via RPC)
* **Arguments and results are serialized** (via `structuredClone`)

The actual function code never leaves its original context!

== Best Practices

1. **Use descriptive names**: `onSave`, `onValidate`, `onCancel`
2. **Return promises**: For async operations
3. **Handle errors**: Always catch and handle errors
4. **Document function signatures**: Use TypeScript types
5. **Batch operations**: Reduce message overhead
6. **Understand the boundary**: Remember that only serializable data crosses
7. **Keep functions in their context**: Don't expect closures to transfer
8. **Cleanup**: Functions are auto-cleaned, but can manually release if needed
